[.env]

MARHI_MONGODB_URI=mongodb+srv://petrklimenko:SgxG1AwKCq9FLgnG@studentsgrades.fhxjnip.mongodb.net/?retryWrites=true&w=majority&appName=StudentsGrades
CLIENT_ID=579047027905-cg8h9n9l6h4fhmvkff9phmev7tpfj3nm.apps.googleusercontent.com
CLIENT_SECRET=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
REDIRECT_URIS=http://localhost:8000/oauth2callback
GMAIL_ACCESS_TOKEN=ya29.a0AcM612xt_ouTRHzTEWfbRjxo92ovLQ-lnMLZRm1KarM0I80GxYBIIkaTgelngY2SHy76th4Ce9voAAgOUrCcfOpZ4X2fZm-uoKqGMCN7UEew0sTe6k5SDPVp_v5p6oWYx9Gae_uH2K7dQ4I5gnTqUKXCFVzyQ9vl6NqdtR8EaCgYKARASARASFQHGX2Miyrlkzgk-NOeYKl5j6kZdKg0175
GMAIL_REFRESH_TOKEN=1//03fIIusel4LYzCgYIARAAGAMSNwF-L9IrKsLT5hVlBvnmbum06m08-33QXFCFHRpvfzs5QEe90gna-P_j4qbv36Uv_gKH52oYKj4


[.env.example]

MARHI_MONGODB_URI=
CLIENT_ID=
CLIENT_SECRET=
REDIRECT_URIS=
GMAIL_ACCESS_TOKEN=
GMAIL_REFRESH_TOKEN=

[.gitignore]

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

.vercel


[api\db\db-connect.js]

// api/db/db-connect.js
require('dotenv').config();
const { MongoClient } = require('mongodb');
const logger = require('../../utils/logger');

let client;
let db;

async function connectToDatabase() {
    if (!client) {
        const uri = process.env.MARHI_MONGODB_URI;
        if (!uri) {
            logger.error('MARHI_MONGODB_URI не определен');
            throw new Error('MARHI_MONGODB_URI is not defined');
        }
        client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });
        try {
            await client.connect();
            db = client.db('MARHI');
            logger.info('Подключение к MongoDB успешно');
        } catch (error) {
            logger.error('Ошибка подключения к MongoDB: %o', error);
            throw error;
        }
    }
    return db;
}

module.exports = connectToDatabase;


[api\db\db-queries.js]

const { ObjectId } = require('mongodb');
const connectToDatabase = require('./db-connect');
const logger = require('../../utils/logger');

class Person {
    constructor({ _id, lastName, firstName, middleName, phoneNumber, email, tgId, tgUserName }) {
        this._id = _id;
        this.lastName = lastName;
        this.firstName = firstName;
        this.middleName = middleName;
        this.phoneNumber = phoneNumber;
        this.email = email;
        this.tgId = tgId;
        this.tgUserName = tgUserName;
    }
}

class Student extends Person {
    constructor({ gradeBookId, ...person }) {
        super(person);
        this.gradeBookId = gradeBookId;
    }
}

class Teacher extends Person {
    constructor({ department, ...person }) {
        super(person);
        this.department = department;
    }
}

async function findPersonById(id) {
    const db = await connectToDatabase();
    const objectId = new ObjectId(id);

    try {
        const student = await db.collection('Students').findOne({ _id: objectId });
        if (student) {
            logger.info('Студент найден с ID: %s', id);
            return new Student({ ...student });
        }

        const teacher = await db.collection('Teachers').findOne({ _id: objectId });
        if (teacher) {
            logger.info('Преподаватель найден с ID: %s', id);
            return new Teacher({ ...teacher });
        }

        logger.warn('Пользователь с ID %s не найден', id);
        return null;
    } catch (error) {
        logger.error('Ошибка при поиске пользователя по ID %s: %o', id, error);
        throw error;
    }
}

async function findStudentByTgId(tgId) {
    const db = await connectToDatabase();
    return db.collection('Students').findOne({ tgId });
}

async function findTeacherByTgId(tgId) {
    const db = await connectToDatabase();
    return db.collection('Teachers').findOne({ tgId });
}

async function findPersonByTgId(tgId) {
    const student = await findStudentByTgId(tgId);
    if (student) {
        return new Student({ ...student });
    }

    const teacher = await findTeacherByTgId(tgId);
    if (teacher) {
        return new Teacher({ ...teacher });
    }

    return null; // Если пользователь не найден
}

async function findPersonByEmail(email) {
    const db = await connectToDatabase();

    console.log(`[db-queries] Ищем среди студентов документ с email: ${email}`);

    const student = await db.collection('Students').findOne({ email });
    if (student) {
        return new Student({ ...student });
    }

    console.log(`[db-queries] Ищем среди преподавателей документ с email: ${email}`);

    const teacher = await db.collection('Teachers').findOne({ email });
    if (teacher) {
        return new Teacher({ ...teacher });
    }

    return null; // Если пользователь не найден
}

async function updatePersonTgId(userId, tgId, collectionName) {
    const db = await connectToDatabase();

    try {
        // Преобразуем строку userId в ObjectId
        const objectId = new ObjectId(userId);

        const result = await db.collection(collectionName).updateOne(
            { _id: objectId }, // Ищем документ по ObjectId
            { $set: { tgId } } // Обновляем поле tgId
        );

        // Проверяем, был ли обновлен документ
        if (result.modifiedCount === 1) {
            console.log(`[updatePersonTgId] tgId успешно обновлен для пользователя с _id: ${userId}`);
        } else {
            console.log(`[updatePersonTgId] Не удалось обновить tgId для пользователя с _id: ${userId}. Документ не найден.`);
        }
    } catch (error) {
        console.error(`[updatePersonTgId] Ошибка при обновлении tgId для пользователя с _id: ${userId}`, error);
    }
}

module.exports = { findPersonById, findPersonByEmail, findStudentByTgId, findTeacherByTgId, findPersonByTgId, updatePersonTgId, Student, Teacher };


[api\google\google-auth.js]

// api/google/google-auth.js
require('dotenv').config();
const { google } = require('googleapis');
const logger = require('../../utils/logger');

async function googleAuthorize() {
    const client_id = process.env.CLIENT_ID;
    const client_secret = process.env.CLIENT_SECRET;
    const redirect_uris = [process.env.REDIRECT_URIS];
  
    if (!client_id || !client_secret || !redirect_uris[0]) {
      logger.error('Переменные окружения для Google API не определены');
      throw new Error('Необходимо определить CLIENT_ID, CLIENT_SECRET и REDIRECT_URIS');
    }
  
    const oAuth2Client = new google.auth.OAuth2(client_id, client_secret, redirect_uris[0]);
  
    const refreshToken = process.env.GMAIL_REFRESH_TOKEN;
  
    if (refreshToken) {
      oAuth2Client.setCredentials({
        refresh_token: refreshToken,
      });
  
      try {
        // Обновляем токен доступа
        await oAuth2Client.getAccessToken();
        logger.info('Авторизация Google OAuth2 успешна');
        return oAuth2Client;
      } catch (error) {
        logger.error('Ошибка при обновлении токена доступа: %o', error);
        throw new Error('Не удалось обновить токен доступа');
      }
    } else {
      logger.error('Токен обновления отсутствует в переменных окружения');
      throw new Error('Токен обновления отсутствует');
    }
  }
  

module.exports = googleAuthorize;


[api\google\google-mail.js]

// api/google/google-mail.js
const { google } = require('googleapis');
const googleAuthorize = require('./google-auth');
const logger = require('../../utils/logger');

async function sendGmailWithRetry(to, subject, message, retryCount = 3) {
    for (let attempt = 1; attempt <= retryCount; attempt++) {
        try {
            await sendGmail(to, subject, message);
            return;
        } catch (error) {
            logger.error('Попытка %d отправки письма не удалась: %o', attempt, error);
            if (attempt === retryCount) {
                logger.error('Письмо не отправлено после %d попыток', retryCount);
                throw new Error('Письмо не отправлено после нескольких попыток');
            }
        }
    }
}

async function sendGmail(to, subject, message) {
    try {
      const startTime = new Date();
      logger.info('Отправка письма на: %s', to);
  
      const auth = await googleAuthorize();
      const gmail = google.gmail({ version: 'v1', auth });
  
      // Подготовка и отправка письма
      const subjectBase64 = `=?UTF-8?B?${Buffer.from(subject).toString('base64')}?=`;
      const email = [
          `To: ${to}`,
          `Subject: ${subjectBase64}`,
          'MIME-Version: 1.0',
          'Content-Type: text/plain; charset="UTF-8"',
          'Content-Transfer-Encoding: 7bit',
          '',
          message,
      ].join('\n');

      const encodedMessage = Buffer.from(email)
          .toString('base64')
          .replace(/\+/g, '-')
          .replace(/\//g, '_')
          .replace(/=+$/, '');
  
      const result = await gmail.users.messages.send({
        userId: 'me',
        requestBody: {
          raw: encodedMessage,
        },
      });
  
      const duration = new Date() - startTime;
      logger.info('Письмо успешно отправлено на %s за %d мс. ID сообщения: %s', to, duration, result.data.id);
  
    } catch (error) {
      logger.error('Ошибка отправки письма на %s: %o', to, error);
  
      // Если ошибка связана с авторизацией, можно попробовать обновить токен
      if (error.code === 401 || error.code === 403) {
        logger.warn('Токен доступа истёк или недействителен. Попытка обновления токена.');
        try {
          await auth.getAccessToken();
          // Повторяем отправку письма
          const result = await gmail.users.messages.send({
            userId: 'me',
            requestBody: {
              raw: encodedMessage,
            },
          });
          const duration = new Date() - startTime;
          logger.info('Письмо успешно отправлено на %s за %d мс после обновления токена. ID сообщения: %s', to, duration, result.data.id);
          return;
        } catch (refreshError) {
          logger.error('Не удалось обновить токен и отправить письмо: %o', refreshError);
          throw refreshError;
        }
      }
  
      throw error;
    }
  }
  
module.exports = sendGmailWithRetry;


[api\student\check-in.js]

// api/student/check-in.js
const { MongoClient, ObjectId } = require('mongodb');
const logger = require('../../utils/logger');

module.exports = async (req, res) => {
  try {
    const { qrCode } = req.body;

    // Подключение к базе данных
    const client = await MongoClient.connect(process.env.MONGODB_URI);
    const db = client.db(process.env.DB_NAME);

    // Получение текущего QR-кода
    const currentQr = await db.collection('currentQrCode').findOne({ _id: 'current' });

    if (!currentQr || currentQr.qrCode !== qrCode) {
      res.status(400).json({ error: 'QR-код недействителен или устарел' });
      return;
    }

    // Получение tgUserId из заголовков
    const tgUserId = req.headers['x-telegram-user-id'];
    if (!tgUserId) {
      res.status(400).json({ error: 'Не удалось идентифицировать пользователя' });
      return;
    }

    const student = await db.collection('Students').findOne({ tgId: tgUserId });

    if (!student) {
      res.status(404).json({ error: 'Студент не найден' });
      return;
    }

    // Получение текущей пары (Class) по дате
    const now = new Date();
    const currentClass = await db.collection('Classes').findOne({
      dateTime: {
        $gte: new Date(now.setHours(0, 0, 0, 0)),
        $lt: new Date(now.setHours(23, 59, 59, 999)),
      },
    });

    if (!currentClass) {
      res.status(404).json({ error: 'Текущая пара не найдена' });
      return;
    }

    // Поиск или создание AttendanceGrades
    let attendanceGrades = await db.collection('Grades').findOne({
      studentId: student._id,
    });

    if (!attendanceGrades) {
      // Создаём новый документ AttendanceGrades
      attendanceGrades = {
        studentId: student._id,
        groupId: student.groupId,
        semesterId: currentClass.semesterId, // Предполагается, что поле semesterId есть
        attendanceRecords: [],
        grades: [],
      };
      const result = await db.collection('Grades').insertOne(attendanceGrades);
      attendanceGrades._id = result.insertedId;
    }

    // Проверяем, не было ли уже отметки для текущего занятия
    if (attendanceGrades.attendanceRecords.includes(currentClass._id)) {
      res.status(200).json({ success: true, message: 'Вы уже отметились на этой паре' });
      return;
    }

    // Добавляем текущий Class ID в attendanceRecords
    await db.collection('Grades').updateOne(
      { _id: attendanceGrades._id },
      { $push: { attendanceRecords: currentClass._id } }
    );

    client.close();

    res.status(200).json({ success: true, message: 'Вы успешно отметились на паре!' });
  } catch (error) {
    logger.error('Ошибка при отметке посещения: %o', error);
    res.status(500).json({ error: 'Ошибка сервера' });
  }
};


[api\teacher\attendance.js]

// api/teacher/attendance.js
const { MongoClient } = require('mongodb');
const logger = require('../../utils/logger');

module.exports = async (req, res) => {
  try {
    // Подключение к базе данных
    const client = await MongoClient.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    const db = client.db(process.env.DB_NAME);

    // Получение списка студентов и их посещаемости
    const students = await db
      .collection('Students')
      .aggregate([
        {
          $lookup: {
            from: 'Grades',
            localField: '_id',
            foreignField: 'studentId',
            as: 'grades',
          },
        },
        {
          $unwind: {
            path: '$grades',
            preserveNullAndEmptyArrays: true,
          },
        },
        {
          $project: {
            _id: 1,
            firstName: 1,
            lastName: 1,
            groupId: 1,
            attendanceCount: {
              $size: { $ifNull: ['$grades.attendanceRecords', []] },
            },
          },
        },
      ])
      .toArray();

    client.close();

    res.status(200).json({ students });
  } catch (error) {
    logger.error('Ошибка при получении посещаемости студентов: %o', error);
    res.status(500).json({ error: 'Ошибка сервера' });
  }
};


[api\teacher\generate-qr.js]

// api/teacher/generate-qr.js
const { MongoClient } = require('mongodb');
const { v4: uuidv4 } = require('uuid');
const logger = require('../../utils/logger');

module.exports = async (req, res) => {
  try {
    // Подключение к базе данных
    const client = await MongoClient.connect(process.env.MONGODB_URI);
    const db = client.db(process.env.DB_NAME);

    // Генерация нового QR-кода
    const qrCode = 'marhi-qr-' + uuidv4().slice(0, 8); // Укорачиваем UUID

    // Обновление или вставка записи в коллекцию
    await db.collection('currentQrCode').updateOne(
      { _id: 'current' },
      { $set: { qrCode, timestamp: new Date() } },
      { upsert: true }
    );

    client.close();

    res.status(200).json({ qrCode });
  } catch (error) {
    logger.error('Ошибка при генерации QR-кода: %o', error);
    res.status(500).json({ error: 'Ошибка сервера' });
  }
};


[api\teacher\student-count.js]

// api/teacher/student-count.js
const { MongoClient } = require('mongodb');
const logger = require('../../utils/logger');

module.exports = async (req, res) => {
  try {
    // Подключение к базе данных
    const client = await MongoClient.connect(process.env.MONGODB_URI);
    const db = client.db(process.env.DB_NAME);

    // Получение текущей пары
    const now = new Date();
    const currentClass = await db.collection('Classes').findOne({
      dateTime: {
        $gte: new Date(now.setHours(0, 0, 0, 0)),
        $lt: new Date(now.setHours(23, 59, 59, 999)),
      },
    });

    if (!currentClass) {
      res.status(200).json({ count: 0 });
      return;
    }

    // Подсчёт количества студентов, отметившихся на текущей паре
    const count = await db.collection('Grades').countDocuments({
      attendanceRecords: currentClass._id,
    });

    client.close();

    res.status(200).json({ count });
  } catch (error) {
    logger.error('Ошибка при получении количества студентов: %o', error);
    res.status(500).json({ error: 'Ошибка сервера' });
  }
};


[api\telegram\telegram-web.js]

export function getTelegramUser() {
    if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
        return window.Telegram.WebApp.initDataUnsafe.user;
    } else {
        console.error("Telegram WebApp не инициализирован или пользователь не доступен");
        return null;
    }
}


[api\user\check-email.js]

// api/user/check-email.js
const { findPersonByEmail } = require('../db/db-queries');
const sendGmailWithRetry = require('../google/google-mail');
const logger = require('../../utils/logger');

module.exports = async (req, res) => {
    try {
        const { email } = req.body;

        logger.info('Получен запрос на проверку email: %s', email);

        const person = await findPersonByEmail(email);
        if (person) {
            logger.info('Пользователь найден: %s %s', person.firstName, person.lastName);

            res.status(200).json({
                _id: person._id,
                email: person.email,
                tgId: person.tgId
            });

            logger.info('Отправка кода регистрации на email: %s', email);

            await sendGmailWithRetry(
                person.email,
                'Код регистрации в MARHIEduTrack',
                `Привет, ${person.firstName}. Чтобы завершить регистрацию, используй код ${person._id}.`
            );
        } else {
            logger.warn('Пользователь с email %s не найден', email);
            res.status(404).json({ error: 'Пользователь не найден' });
        }
    } catch (error) {
        logger.error('Ошибка в обработке запроса check-email: %o', error);
        res.status(500).json({ error: 'Ошибка сервера' });
    }
};


[api\user\find-by-tgId.js]

// api/user/find-by-tgId.js
const { findPersonByTgId, Student, Teacher } = require('../db/db-queries');
const logger = require('../../utils/logger');

module.exports = async (req, res) => {
    let { tgId } = req.query;

    logger.info('Получен запрос на поиск пользователя с tgId: %s', tgId);

    tgId = parseInt(tgId, 10);

    try {
        const person = await findPersonByTgId(tgId);
        if (person) {
            logger.info('Пользователь найден: %s %s', person.firstName, person.lastName);
            const userType = person instanceof Student ? 'student' : 'teacher';
            res.status(200).json({
                found: true,
                type: userType,
                ...person
            });
        } else {
            logger.warn('Пользователь с tgId %s не найден', tgId);
            res.status(200).json({ found: false });
        }
    } catch (error) {
        logger.error('Ошибка при поиске пользователя с tgId %s: %o', tgId, error);
        res.status(500).json({ error: 'Ошибка сервера' });
    }
};


[api\user\verify-code.js]

// api/user/verify-code.js
const { findPersonById, updatePersonTgId, Student, Teacher } = require('../db/db-queries');
const logger = require('../../utils/logger');

module.exports = async (req, res) => {
    const { _id, code, tgUserId } = req.body;

    logger.info('Получен запрос на верификацию кода для пользователя с ID: %s', _id);

    try {
        if (_id === code) {
            logger.info('Код подтверждения верен для пользователя с ID: %s', _id);

            const person = await findPersonById(_id);
            if (person) {
                logger.info('Пользователь найден: %s %s', person.firstName, person.lastName);

                const collectionName = person instanceof Student ? 'Students' : 'Teachers';
                await updatePersonTgId(_id, tgUserId, collectionName);

                logger.info('tgId обновлен для пользователя с ID: %s', _id);

                res.status(200).json({ message: 'Регистрация завершена' });
            } else {
                logger.warn('Пользователь с ID %s не найден', _id);
                res.status(404).json({ error: 'Пользователь не найден' });
            }
        } else {
            logger.warn('Неверный код подтверждения для пользователя с ID: %s', _id);
            res.status(400).json({ error: 'Неверный код' });
        }
    } catch (error) {
        logger.error('Ошибка при верификации кода для пользователя с ID %s: %o', _id, error);
        res.status(500).json({ error: 'Ошибка сервера' });
    }
};


[package.json]

{
  "name": "marchi-edu-track-miniapp",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@babel/plugin-transform-private-property-in-object": "^7.24.7",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@fontsource/roboto": "^5.1.0",
    "@mui/icons-material": "^6.1.1",
    "@mui/material": "^6.1.1",
    "dotenv": "^16.4.5",
    "googleapis": "^144.0.0",
    "jsqr": "^1.4.0",
    "mongodb": "^4.0.0",
    "qrcode.react": "^4.0.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-qr-scanner": "^1.0.0-alpha.11",
    "react-router-dom": "^6.26.2",
    "react-scripts": "5.0.1",
    "winston": "^3.14.2"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "web-vitals": "^2.1.4"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


[public\index.html]

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARHI EduTrack</title>
</head>
<body>
    <div id="root"></div>

    <!-- Подключение скрипта Telegram WebApp -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <!-- Ваши основные скрипты React -->
</body>
</html>


[public\vercel.json]

{
    "builds": [
      {
        "src": "src/index.js",
        "use": "@vercel/node"
      }
    ],
    "routes": [
      {
        "src": "/api/(.*)",
        "dest": "/api/$1"
      }
    ]
  }
  

[README.md]

## Настройка переменных окружения

Перед запуском приложения создайте файл `.env` в корне проекта и укажите необходимые переменные:

```env
MARHI_MONGODB_URI=ваш_новый_mongodb_uri
CLIENT_ID=ваш_новый_client_id
CLIENT_SECRET=ваш_новый_client_secret
REDIRECT_URIS=ваш_redirect_uri
GMAIL_ACCESS_TOKEN=ваш_новый_gmail_access_token
GMAIL_REFRESH_TOKEN=ваш_новый_gmail_refresh_token




# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


[rename-case.sh]

#!/bin/bash

# Функция для временного переименования и последующего изменения регистра
rename_case() {
  local original_path=$1
  local temp_path="${original_path}_temp"

  # Переименование во временное имя
  git mv "$original_path" "$temp_path"
  git commit -m "Переименовал $original_path во временное имя для изменения регистра"

  # Переименование в окончательное имя с правильным регистром
  local desired_path=$(echo "$original_path" | sed 's/\b\(.\)/\u\1/g') # Пример преобразования первой буквы в верхний регистр
  git mv "$temp_path" "$desired_path"
  git commit -m "Переименовал $temp_path в $desired_path с изменением регистра"
}

# Пример использования функции для нескольких файлов
rename_case "src/components/home.js"
# rename_case "src/components/registrationForm.js"
# rename_case "src/components/protectedRoute.js"

# Продолжите добавлять вызовы функции для остальных файлов и папок


[src\App.js]

// src/App.js
import React, { useEffect, useState } from 'react';
import { Routes, Route } from 'react-router-dom';
import Home from './components/Home';
import StudentDashboard from './components/student/StudentDashboard';
import TeacherDashboard from './components/teacher/TeacherDashboard';
import RegistrationForm from './components/RegistrationForm';
import ProtectedRoute from './components/ProtectedRoute';
import { ThemeProvider } from '@mui/material/styles';
import { getTheme } from './theme';
import CssBaseline from '@mui/material/CssBaseline'; // Импортируем CssBaseline

function App() {
  const [theme, setTheme] = useState(getTheme(window.Telegram?.WebApp?.themeParams || {}));

  useEffect(() => {
    const onThemeChanged = () => {
      const newThemeParams = window.Telegram.WebApp.themeParams;
      setTheme(getTheme(newThemeParams));
    };

    window.Telegram.WebApp.onEvent('themeChanged', onThemeChanged);

    return () => {
      window.Telegram.WebApp.offEvent('themeChanged', onThemeChanged);
    };
  }, []);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline /> {/* Добавляем CssBaseline */}
      <div className="App">
        <Routes>
          {/* Главная страница */}
          <Route path="/" element={<Home />} />

          {/* Страницы для студентов */}
          <Route
            path="/student/*"
            element={
              <ProtectedRoute allowedRoles={['student']}>
                <StudentDashboard />
              </ProtectedRoute>
            }
          />

          {/* Страницы для преподавателей */}
          <Route
            path="/teacher/*"
            element={
              <ProtectedRoute allowedRoles={['teacher']}>
                <TeacherDashboard />
              </ProtectedRoute>
            }
          />

          {/* Страница регистрации */}
          <Route path="/register" element={<RegistrationForm />} />
        </Routes>
      </div>
    </ThemeProvider>
  );
}

export default App;


[src\components\Home.js]

// src/components/home.js
import React, { useContext } from 'react';
import { UserContext } from '../context/UserContext';
import { Navigate } from 'react-router-dom';
import RegistrationForm from './RegistrationForm';
import Loading from './Loading'; // Импортируем компонент Loading
import { Box, Typography } from '@mui/material'; // Импортируем компоненты MUI

function Home() {
  const { user } = useContext(UserContext);

  if (user === undefined) {
    // Если пользователь ещё загружается, показываем индикатор загрузки
    return <Loading message="Подождите, идет загрузка..." />;
  }

  if (user === null) {
    // Если пользователь не найден, показываем форму регистрации
    return <RegistrationForm />;
  } else if (user.type === 'student') {
    // Перенаправляем студента на его дашборд
    return <Navigate to="/student" replace />;
  } else if (user.type === 'teacher') {
    // Перенаправляем преподавателя на его дашборд
    return <Navigate to="/teacher" replace />;
  } else {
    // Непредвиденный тип пользователя
    return (
      <Box
        sx={{
          minHeight: '100vh',
          backgroundColor: 'background.default',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
        }}
      >
        <Typography variant="h6" color="error">
          Ошибка: неизвестный тип пользователя
        </Typography>
      </Box>
    );
  }
}

export default Home;


[src\components\Loading.js]

// src/components/Loading.js
import React from 'react';
import { Box, CircularProgress, Typography } from '@mui/material';

function Loading({ message = 'Загрузка...' }) {
  return (
    <Box
      display="flex"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      height="100vh"
      bgcolor="background.default"
    >
      <CircularProgress color="primary" size={60} />
      <Typography variant="h6" mt={2}>
        {message}
      </Typography>
    </Box>
  );
}

export default Loading;


[src\components\ProtectedRoute.js]

// src/components/protectedRoute.js
import React, { useContext } from 'react';
import { UserContext } from '../context/UserContext';
import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children, allowedRoles }) {
  const { user } = useContext(UserContext);

  if (user === undefined) {
    // Если пользователь ещё загружается, можно показать индикатор загрузки
    return <div>Загрузка...</div>;
  }

  if (!user) {
    // Если пользователь не авторизован, перенаправляем на страницу регистрации
    return <Navigate to="/register" replace />;
  }

  if (!allowedRoles.includes(user.type)) {
    // Если роль пользователя не соответствует разрешённым, показываем сообщение об ошибке
    return <div>Доступ запрещён</div>;
  }

  return children;
}

export default ProtectedRoute;


[src\components\RegistrationForm.js]

// src/components/registrationForm.js
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { handleApiRequest } from '../utils/api-helpers';
import logger from '../utils/logger';
import { TextField, Button, Typography, Container } from '@mui/material';

function RegistrationForm() {
  const [email, setEmail] = useState('');
  const [code, setCode] = useState('');
  const [isRegistered, setIsRegistered] = useState(false);
  const navigate = useNavigate();
  const [error, setError] = useState('');

  useEffect(() => {
    const tgUser = window.Telegram?.WebApp?.initDataUnsafe?.user;
    if (!tgUser) {
      logger.error('Не удалось инициализировать Telegram WebApp.');
      alert('Не удалось инициализировать Telegram WebApp.');
      return;
    }
    logger.info('Telegram WebApp успешно инициализирован. Пользователь: ', tgUser);
  }, []);

  // Добавляем новый useEffect для перенаправления после успешной регистрации
  useEffect(() => {
    if (isRegistered) {
      console.log('Navigating immediately without timeout');
      navigate('/', { replace: true });
    }
  }, [isRegistered, navigate]);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    const data = await handleApiRequest('/api/user/check-email', { email });
    if (data) {
      localStorage.setItem('dbUserId', data._id);
      setError('');
      logger.info('Код отправлен на email: %s', email);
    } else {
      setError('Пользователь не найден');
      logger.warn('Пользователь с email %s не найден', email);
    }
  };

  const handleVerify = async () => {
    const tgUser = window.Telegram?.WebApp?.initDataUnsafe?.user;
    const dbUserId = localStorage.getItem('dbUserId');
    const data = await handleApiRequest('/api/user/verify-code', {
      _id: dbUserId,
      code,
      tgUserId: tgUser?.id,
    });
    if (data) {
      setIsRegistered(true); // Устанавливаем isRegistered в true
      console.log('isRegistered set to true');
      setError('');
      logger.info('Пользователь успешно зарегистрирован с tgId: %s', tgUser?.id);
    } else {
      setError('Неверный код');
      logger.warn('Введён неверный код для пользователя с ID: %s', dbUserId);
    }
  };

  return isRegistered ? (
    <Container maxWidth="sm">
      <Typography variant="h5" align="center" gutterBottom>
        Вы успешно зарегистрировались!
      </Typography>
      <Typography variant="body1" align="center">
        Сейчас вы будете перенаправлены...
      </Typography>
    </Container>
  ) : (
    <Container maxWidth="sm">
      <Typography variant="h5" align="center" gutterBottom>
        Регистрация
      </Typography>
      <form onSubmit={handleSubmit}>
        <TextField
          label="Email"
          variant="outlined"
          fullWidth
          margin="normal"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
        <Button type="submit" variant="outlined" fullWidth>
          Отправить
        </Button>
      </form>

      <div style={{ marginTop: '20px' }}>
        <TextField
          label="Введите код"
          variant="outlined"
          fullWidth
          margin="normal"
          value={code}
          onChange={(e) => setCode(e.target.value)}
          required
        />
        <Button onClick={handleVerify} variant="outlined" fullWidth>
          Проверить
        </Button>
      </div>

      {error && (
        <Typography variant="body2" color="error" align="center">
          {error}
        </Typography>
      )}
    </Container>
  );
}

export default RegistrationForm;


[src\components\SessionCard.js]

// src/components/SessionCard.js
import React from 'react';
import { Card, CardContent, Typography, Chip, Box, Stack } from '@mui/material';

function SessionCard({
  title,
  topic,
  dateTime,
  assignment,
  attendance,
}) {
  const attendanceColors = {
    present: 'success',
    absent: 'error',
  };

  const attendanceLabels = {
    present: 'Присутствует',
    absent: 'Отсутствует',
  };

  return (
    <Card variant="outlined" sx={{ width: '100%' }}>
      <CardContent>
        {/* Заголовок Карточки */}
        <Typography variant="h6" component="div" gutterBottom>
          {title}
        </Typography>

        {/* Тема Пары */}
        <Box sx={{ marginBottom: 1 }}>
          <Typography variant="subtitle1" color="text.secondary">
            Тема пары:
          </Typography>
          <Typography variant="body1">{topic}</Typography>
        </Box>

        {/* Дата и Время */}
        <Box sx={{ marginBottom: 1 }}>
          <Typography variant="subtitle1" color="text.secondary">
            Дата и время проведения:
          </Typography>
          <Typography variant="body1">{dateTime}</Typography>
        </Box>

        {/* Задание */}
        <Box sx={{ marginBottom: 1 }}>
          <Typography variant="subtitle1" color="text.secondary">
            Задание:
          </Typography>
          <Typography variant="body1">{assignment}</Typography>
        </Box>

        {/* Отметка Присутствия/Отсутствия */}
        <Stack direction="row" spacing={1} alignItems="center">
          <Typography variant="subtitle1" color="text.secondary">
            Статус:
          </Typography>
          <Chip
            label={attendanceLabels[attendance]}
            color={attendanceColors[attendance]}
          />
        </Stack>
      </CardContent>
    </Card>
  );
}

export default SessionCard;


[src\components\student\StudentDashboard.js]

// src/components/student/studentDashboard.js
import React, { useState, useEffect } from 'react';
import { Routes, Route, useNavigate, useLocation } from 'react-router-dom';
import StudentProfile from './StudentProfile';
import StudentQRCheck from './StudentQRCheck';
import StudentStatistics from './StudentStatistics';
import { Container, Tabs, Tab } from '@mui/material';
import AccountCircleOutlinedIcon from '@mui/icons-material/AccountCircleOutlined';
import CameraAltOutlinedIcon from '@mui/icons-material/CameraAltOutlined';
import InsertChartOutlinedIcon from '@mui/icons-material/InsertChartOutlined';

function StudentDashboard() {
  const navigate = useNavigate();
  const location = useLocation();

  const tabNameToIndex = {
    '/student/profile': 0,
    '/student/qr': 1,
    '/student/statistics': 2,
  };

  const indexToTabName = {
    0: 'profile',
    1: 'qr',
    2: 'statistics',
  };

  const [value, setValue] = useState(tabNameToIndex[location.pathname] || 0);

  useEffect(() => {
    setValue(tabNameToIndex[location.pathname] || 0);
  }, [location.pathname]);

  useEffect(() => {
    if (location.pathname === '/student') {
      navigate('profile');
    }
  }, [location.pathname, navigate]);

  const handleChange = (event, newValue) => {
    navigate(indexToTabName[newValue]);
  };

  return (
    <Container maxWidth="md">
      {/* Вкладки с иконками */}
      <Tabs value={value} onChange={handleChange} aria-label="icon tabs" centered>
        <Tab icon={<AccountCircleOutlinedIcon />} aria-label="profile" label="Profile" />
        <Tab icon={<CameraAltOutlinedIcon />} aria-label="qr" label="QR" />
        <Tab icon={<InsertChartOutlinedIcon />} aria-label="statistics" label="Statistics" />
      </Tabs>

      {/* Маршруты */}
      <Routes>
        <Route path="profile" element={<StudentProfile />} />
        <Route path="qr" element={<StudentQRCheck />} />
        <Route path="statistics" element={<StudentStatistics />} />
      </Routes>
    </Container>
  );
}

export default StudentDashboard;


[src\components\student\StudentProfile.js]

// src/components/student/studentProfile.js
import React, { useContext, useEffect, useState } from 'react';
import { UserContext } from '../../context/UserContext';
import { Container, Typography } from '@mui/material';

function StudentProfile() {
  const { user } = useContext(UserContext);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (user) {
      setLoading(false);
    }
  }, [user]);

  if (loading) {
    return (
      <Container>
        <Typography variant="h5">Загрузка профиля...</Typography>
      </Container>
    );
  }

  return (
    <Container>
      <Typography variant="h5" gutterBottom>
        Профиль Студента
      </Typography>
      <Typography variant="body1">Имя: {user.firstName}</Typography>
      <Typography variant="body1">Фамилия: {user.lastName}</Typography>
      <Typography variant="body1">Номер зачётки: {user.gradeBookId}</Typography>
    </Container>
  );
}

export default StudentProfile;


[src\components\student\StudentQRCheck.js]

// src/components/student/studentQRCheck.js
import React, { useRef, useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import jsQR from 'jsqr';
import { handleApiRequest } from '../../utils/api-helpers';
import { Container, Typography, Alert, Box, Button, Paper } from '@mui/material';

function StudentQRCheck() {
  const videoRef = useRef(null);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [streaming, setStreaming] = useState(false);
  const canvasRef = useRef(null);
  const navigate = useNavigate();

  const startCamera = () => {
    setStreaming(true);
  };

  const tick = () => {
    if (videoRef.current && videoRef.current.readyState === videoRef.current.HAVE_ENOUGH_DATA) {
      const canvas = canvasRef.current.getContext('2d');
      canvasRef.current.width = videoRef.current.videoWidth;
      canvasRef.current.height = videoRef.current.videoHeight;
      canvas.drawImage(
        videoRef.current,
        0,
        0,
        canvasRef.current.width,
        canvasRef.current.height
      );

      const imageData = canvas.getImageData(
        0,
        0,
        canvasRef.current.width,
        canvasRef.current.height
      );
      const code = jsQR(
        imageData.data,
        canvasRef.current.width,
        canvasRef.current.height
      );

      if (code) {
        // QR-код распознан
        handleScanResult(code.data);
        setStreaming(false);
      } else {
        requestAnimationFrame(tick);
      }
    } else {
      requestAnimationFrame(tick);
    }
  };

  const handleScanResult = async (qrCode) => {
    if (qrCode && qrCode.startsWith('marhi-qr-')) {
      try {
        // Получение tgUserId из Telegram WebApp
        const tgUserId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id;

        const data = await handleApiRequest(
          '/api/student/check-in',
          { qrCode },
          'POST',
          { 'x-telegram-user-id': tgUserId }
        );

        if (data && data.success) {
          setSuccess(data.message || 'Вы успешно отметились на паре!');
        } else {
          setError(data.error || 'Ошибка при отметке посещения.');
        }
      } catch (err) {
        console.error('Ошибка при отметке посещения:', err);
        setError('Ошибка при отметке посещения.');
      }
    } else {
      setError('Неверный QR-код. Попробуйте снова.');
    }
  };

  useEffect(() => {
    let stream;
    if (streaming) {
      navigator.mediaDevices
        .getUserMedia({ video: { facingMode: 'environment' } })
        .then((s) => {
          stream = s;
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            videoRef.current.setAttribute('playsinline', true); // Для iOS
            videoRef.current.play();
            requestAnimationFrame(tick);
          } else {
            console.error('videoRef.current is null');
            setError('Ошибка: видеоэлемент недоступен.');
            setStreaming(false);
          }
        })
        .catch((err) => {
          console.error('Ошибка при доступе к камере:', err);
          setError('Ошибка при доступе к камере: ' + err.message);
          setStreaming(false);
        });
    }

    return () => {
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
      }
      if (videoRef.current) {
        videoRef.current.srcObject = null;
      }
    };
  }, [streaming]);

  return (
    <Container maxWidth="sm">
      <Typography variant="h5" align="center" gutterBottom>
        Отметка посещения
      </Typography>

      {success ? (
        <Alert severity="success">{success}</Alert>
      ) : (
        <>
          {error && <Alert severity="error">{error}</Alert>}
          <Typography variant="body1" align="center" gutterBottom>
            Наведите камеру на QR-код, чтобы отметиться на паре.
          </Typography>
          {!streaming && (
            <Button variant="contained" color="primary" onClick={startCamera}>
              Открыть камеру
            </Button>
          )}
          <Box display="flex" justifyContent="center" mt={2}>
            <Paper
              elevation={3}
              style={{
                width: '70%',
                height: '70%',
                borderRadius: '16px',
                overflow: 'hidden',
              }}
            >
              <video
                ref={videoRef}
                style={{
                  width: '100%',
                  height: '100%',
                  borderRadius: '16px',
                  display: streaming ? 'block' : 'none',
                  objectFit: 'cover',
                }}
              />
              <canvas
                ref={canvasRef}
                style={{ display: 'none' }}
              />
            </Paper>
          </Box>
        </>
      )}
    </Container>
  );
}

export default StudentQRCheck;


[src\components\student\StudentStatistics.js]

// src/components/student/studentStatistics.js
import React from 'react';
import { Container, Typography } from '@mui/material';

function StudentStatistics() {
  return (
    <Container>
      <Typography variant="h5" gutterBottom>
        Статистика Студента
      </Typography>
      <Typography variant="body1">Скоро здесь появится статистика</Typography>
    </Container>
  );
}

export default StudentStatistics;


[src\components\teacher\TeacherAttendance.js]

// src/components/teacher/teacherAttendance.js
import React, { useEffect, useState } from 'react';
import { handleApiRequest } from '../../utils/api-helpers';
import {
  Container,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
} from '@mui/material';

function TeacherAttendance() {
  const [students, setStudents] = useState([]);

  useEffect(() => {
    const fetchAttendance = async () => {
      try {
        const data = await handleApiRequest('/api/teacher/attendance', null, 'GET');
        if (data && data.students) {
          setStudents(data.students);
        }
      } catch (error) {
        console.error('Ошибка при получении посещаемости', error);
      }
    };

    fetchAttendance();
  }, []);

  return (
    <Container maxWidth="md">
      <Typography variant="h5" align="center" gutterBottom>
        Посещаемость студентов
      </Typography>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>Фамилия</TableCell>
            <TableCell>Имя</TableCell>
            <TableCell>Группа</TableCell>
            <TableCell>Посещенные занятия</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {students.map((student) => (
            <TableRow key={student._id}>
              <TableCell>{student.lastName}</TableCell>
              <TableCell>{student.firstName}</TableCell>
              <TableCell>{student.groupId}</TableCell>
              <TableCell>{student.attendanceCount}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </Container>
  );
}

export default TeacherAttendance;


[src\components\teacher\TeacherDashboard.js]

// src/components/teacher/teacherDashboard.js
import React, { useState } from 'react';
import { Routes, Route, useNavigate } from 'react-router-dom';
import TeacherProfile from './TeacherProfile';
import TeacherQRGenerator from './TeacherQRGenerator';
import TeacherAttendance from './TeacherAttendance';
import { Container, Tabs, Tab } from '@mui/material';
import AccountCircleOutlinedIcon from '@mui/icons-material/AccountCircleOutlined';
import CameraAltOutlinedIcon from '@mui/icons-material/CameraAltOutlined';
import ListIcon from '@mui/icons-material/List';

function TeacherDashboard() {
  const [value, setValue] = useState(0);
  const navigate = useNavigate();

  const handleChange = (event, newValue) => {
    setValue(newValue);

    // Перенаправляем на нужный маршрут при изменении вкладки
    if (newValue === 0) navigate('profile');
    if (newValue === 1) navigate('qr');
    if (newValue === 2) navigate('attendance');
  };

  return (
    <Container maxWidth="md">
      {/* Вкладки с иконками */}
      <Tabs value={value} onChange={handleChange} aria-label="icon tabs" centered>
        <Tab icon={<AccountCircleOutlinedIcon />} aria-label="profile" label="Profile" />
        <Tab icon={<CameraAltOutlinedIcon />} aria-label="qr" label="QR" />
        <Tab icon={<ListIcon />} aria-label="attendance" label="Attendance" />
      </Tabs>

      {/* Маршруты */}
      <Routes>
        <Route path="profile" element={<TeacherProfile />} />
        <Route path="qr" element={<TeacherQRGenerator />} />
        <Route path="attendance" element={<TeacherAttendance />} />
      </Routes>
    </Container>
  );
}

export default TeacherDashboard;


[src\components\teacher\TeacherProfile.js]

// src/components/teacher/TeacherProfile.js
import React, { useContext } from 'react';
import { UserContext } from '../../context/UserContext';
import { Box, Typography, Stack } from '@mui/material';
import SessionCard from '../SessionCard';

function TeacherProfile() {
  const { user } = useContext(UserContext);

  if (!user) return null;

  // Пример данных для карточек
  const classSessions = [
    {
      title: 'Предыдущая пара',
      topic: 'Введение в математический анализ',
      dateTime: '01.09.2024, 10:00 - 11:30',
      assignment: 'Прочитать главы 1-2 и решить упражнения 1.1-1.5',
      attendance: 'present',
    },
    {
      title: 'Текущая пара',
      topic: 'Линейная алгебра',
      dateTime: '02.09.2024, 12:00 - 13:30',
      assignment: 'Решить задачи 2.1-2.3 и подготовить презентацию',
      attendance: 'absent',
    },
    {
      title: 'Следующая пара',
      topic: 'Дифференциальные уравнения',
      dateTime: '03.09.2024, 14:00 - 15:30',
      assignment: 'Подготовить доклад по теме "Методы решения уравнений"',
      attendance: 'present',
    },
  ];

  return (
    <Box sx={{ padding: 2, backgroundColor: 'background.default', minHeight: '100vh' }}>
      <Typography variant="h4" gutterBottom>
        Профиль Преподавателя
      </Typography>
      <Box sx={{ marginBottom: 4 }}>
        <Typography variant="body1">ID: {user.tgId}</Typography>
        <Typography variant="body1">Имя: {user.firstName}</Typography>
        <Typography variant="body1">Фамилия: {user.lastName}</Typography>
        <Typography variant="body1">Кафедра: {user.department}</Typography>
        {/* Добавьте дополнительную информацию по необходимости */}
      </Box>

      {/* Карточки с информацией о парах */}
      <Stack spacing={3}>
        {classSessions.map((session, index) => (
          <SessionCard
            key={index}
            title={session.title}
            topic={session.topic}
            dateTime={session.dateTime}
            assignment={session.assignment}
            attendance={session.attendance}
          />
        ))}
      </Stack>
    </Box>
  );
}

export default TeacherProfile;


[src\components\teacher\TeacherQRGenerator.js]

// src/components/teacher/teacherQRGenerator.js
import React, { useState, useEffect } from 'react';
import { QRCodeCanvas } from 'qrcode.react';
import { Container, Typography } from '@mui/material';
import { handleApiRequest } from '../../utils/api-helpers';

function TeacherQRGenerator() {
  const [qrCodeValue, setQrCodeValue] = useState('');
  const [timer, setTimer] = useState(10);
  const [studentCount, setStudentCount] = useState(0);

  useEffect(() => {
    // Функция для генерации нового QR-кода
    const generateQrCode = async () => {
      try {
        const data = await handleApiRequest('/api/teacher/generate-qr', null, 'GET');
        if (data && data.qrCode) {
          setQrCodeValue(data.qrCode);
          setTimer(10); // Сброс таймера
        }
      } catch (error) {
        console.error('Ошибка при генерации QR-кода', error);
      }
    };

    // Функция для получения количества отметившихся студентов
    const fetchStudentCount = async () => {
      try {
        const data = await handleApiRequest('/api/teacher/student-count', null, 'GET');
        if (data && data.count !== undefined) {
          setStudentCount(data.count);
        }
      } catch (error) {
        console.error('Ошибка при получении количества студентов', error);
      }
    };

    // Генерируем QR-код при загрузке компонента
    generateQrCode();
    fetchStudentCount();

    // Устанавливаем интервал для обновления QR-кода каждые 10 секунд
    const interval = setInterval(() => {
      generateQrCode();
      fetchStudentCount();
    }, 10000);

    // Обновление таймера каждую секунду
    const countdown = setInterval(() => {
      setTimer((prev) => (prev > 0 ? prev - 1 : 10));
    }, 1000);

    return () => {
      clearInterval(interval);
      clearInterval(countdown);
    };
  }, []);

  return (
    <Container maxWidth="sm">
      <Typography variant="h5" align="center" gutterBottom>
        Генерация QR-кода для отметки посещений
      </Typography>
      {qrCodeValue ? (
        <div style={{ textAlign: 'center' }}>
          <QRCodeCanvas value={qrCodeValue} size={256} />
          <Typography variant="body1" align="center">
            Обновление через: {timer} секунд
          </Typography>
          <Typography variant="body1" align="center">
            Отметилось студентов: {studentCount}
          </Typography>
        </div>
      ) : (
        <Typography variant="body1" align="center">
          Генерация QR-кода...
        </Typography>
      )}
    </Container>
  );
}

export default TeacherQRGenerator;


[src\context\UserContext.js]

// src/context/userContext.js
import React, { createContext, useState, useEffect } from 'react';
import { handleApiRequest } from '../utils/api-helpers';

export const UserContext = createContext();

export const UserProvider = ({ children }) => {
  const [user, setUser] = useState(undefined); // Начальное значение undefined

  useEffect(() => {
    const fetchUser = async () => {
      const tgId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id;
      if (!tgId) {
        console.error('Telegram user ID не найден');
        setUser(null);
        return;
      }
      const data = await handleApiRequest(`/api/user/find-by-tgId?tgId=${tgId}`, null, 'GET');
      if (data?.found) {
        setUser(data);
      } else {
        setUser(null);
      }
    };
    fetchUser();
  }, []);

  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
};


[src\index.js]

// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { UserProvider } from './context/UserContext';
import { ThemeProvider } from '@mui/material/styles';
import { getTheme } from './theme';
import CssBaseline from '@mui/material/CssBaseline';
import App from './App';

// Импорт шрифтов и базовых стилей MUI
import '@fontsource/roboto/300.css';
import '@fontsource/roboto/400.css';
import '@fontsource/roboto/500.css';
import '@fontsource/roboto/700.css';

const themeParams = window.Telegram?.WebApp?.themeParams || {};
const theme = getTheme(themeParams);

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <UserProvider>
        <ThemeProvider theme={theme}>
        <CssBaseline />
        <App />
        </ThemeProvider>
      </UserProvider>
    </BrowserRouter>
  </React.StrictMode>
);


[src\styles.css]

/* src/styles.css */

/* Удалите или закомментируйте эти стили */
/*
body {
  font-family: Arial, sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background-color: #f0f0f0;
}

.App {
  text-align: center;
  background-color: #fff;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

h1 {
  color: #0088cc;
}

button {
  background-color: #0088cc;
  color: #fff;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

button:hover {
  background-color: #0077bb;
}

input {
  padding: 10px;
  margin: 5px 0;
  border-radius: 5px;
  border: 1px solid #ccc;
}
*/


[src\theme.js]

// theme.js
import { createTheme } from '@mui/material/styles';

// Функция для преобразования HEX-цвета в яркость
const getBrightness = (hexColor) => {
  const hex = hexColor.replace('#', '');

  // Разбиваем цвет на составляющие (R, G, B)
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);

  // Вычисляем яркость
  return (0.299 * r + 0.587 * g + 0.114 * b);
};

export const getTheme = (themeParams) => {
  const bgColor = themeParams?.bg_color || '#ffffff';
  const brightness = getBrightness(bgColor); // Вычисляем яркость
  // const isLightTheme = brightness > 128; // Определяем, светлая тема или тёмная
  const isLightTheme = true; // Временное решение

  return createTheme({
    palette: {
      mode: isLightTheme ? 'light' : 'dark', // Светлая или тёмная тема
      background: {
        default: isLightTheme ? '#ffffff' : '#000000',
        // default: bgColor,
      },
      text: {
        primary: isLightTheme ? '#000000' : '#ffffff', // Текст зависит от яркости
      },
      primary: {
        main: themeParams?.button_color || '#0088cc', // Бирюзовый цвет при наведении
        contrastText: themeParams?.button_text_color || '#ffffff',
      },
    },
    typography: {
      allVariants: {
        color: isLightTheme ? '#000000' : '#ffffff',
      },
    },
    components: {
      MuiTypography: {
        styleOverrides: {
          root: {
            color: isLightTheme ? '#000000' : '#ffffff',
          },
        },
      },
      MuiTextField: {
        styleOverrides: {
          root: {
            '& .MuiOutlinedInput-root': {
              '& fieldset': {
                borderColor: isLightTheme ? '#000000' : '#ffffff', // Черная обводка в светлой теме, белая в тёмной
              },
              '&:hover fieldset': {
                borderColor: themeParams?.button_color || '#0088cc', // Бирюзовая обводка при наведении
              },
              '&.Mui-focused fieldset': {
                borderColor: themeParams?.button_color || '#0088cc', // Бирюзовая обводка при фокусе
              },
            },
          },
        },
      },
      MuiButton: {
        styleOverrides: {
          root: {
            borderColor: isLightTheme ? '#000000' : '#ffffff', // Черная обводка в светлой теме, белая в тёмной
            color: isLightTheme ? '#000000' : '#ffffff', // Черный текст в светлой теме, белый в темной
            '&:hover': {
              backgroundColor: themeParams?.button_color || '#0088cc', // Бирюзовый фон при наведении
              color: themeParams?.button_text_color || '#ffffff', // Белый текст при наведении
            },
          },
        },
      },
      MuiTabs: {
        styleOverrides: {
          root: {
            color: isLightTheme ? '#000000' : '#ffffff',
          },
          indicator: {
            backgroundColor: themeParams?.button_color || '#0088cc',
          },
        },
      },
      MuiTab: {
        styleOverrides: {
          root: {
            color: isLightTheme ? '#000000' : '#ffffff',
            '&.Mui-selected': {
              color: themeParams?.button_color || '#0088cc',
            },
          },
        },
      },
    },
  });
};


[src\utils\api-helpers.js]

// src/utils/api-helpers.js
import logger from './logger';

export async function handleApiRequest(url, body, method = 'POST') {
  try {
    const options = {
      method,
      headers: { 'Content-Type': 'application/json' }
    };

    if (method !== 'GET' && body) {
      options.body = JSON.stringify(body);
    }

    const response = await fetch(url, options);

    if (response.status === 404) {
      throw new Error('Маршрут не найден (404)');
    }

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Ошибка запроса: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const data = await response.json();
    logger.info('Успешный ответ от %s: %o', url, data);
    return data;
  } catch (error) {
    logger.error('Ошибка при выполнении запроса к %s: %o', url, error);
    return null;
  }
}


[src\utils\logger.js]

const isDevelopment = process.env.NODE_ENV === 'development';

const logger = {
  log: (...args) => {
    if (isDevelopment) {
      console.log(...args);
    }
  },
  info: (...args) => {
    if (isDevelopment) {
      console.info(...args);
    }
  },
  warn: (...args) => {
    if (isDevelopment) {
      console.warn(...args);
    }
  },
  error: (...args) => {
    if (isDevelopment) {
      console.error(...args);
    }
  },
};

export default logger;


[utils\logger.js]

// utils/logger.js

const { createLogger, format, transports } = require('winston');

const logger = createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug', // Уровень логирования
  format: format.combine(
    format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }), // Форматирование метки времени
    format.printf(info => `${info.timestamp} [${info.level.toUpperCase()}]: ${info.message}`) // Форматирование сообщения
  ),
  transports: [
    new transports.Console() // Вывод логов в консоль
  ],
});

module.exports = logger;


